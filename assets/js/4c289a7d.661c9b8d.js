"use strict";(self.webpackChunkcspr_docs_redux=self.webpackChunkcspr_docs_redux||[]).push([[62993],{1659:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"zug","title":"Zug consensus in Casper 2.0","description":"A discussion of the Zug consensus model","source":"@site/condor/zug.md","sourceDirName":".","slug":"/zug","permalink":"/condor/zug","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"v2","permalink":"/condor/tags/v-2"},{"inline":true,"label":"consensus","permalink":"/condor/tags/consensus"}],"version":"current","frontMatter":{"title":"Zug consensus in Casper 2.0","description":"A discussion of the Zug consensus model","slug":"zug","date":"2024-10-03T18:00","authors":["alexanderlimonov"],"tags":["v2","consensus"],"hide_table_of_contents":false},"sidebar":"condorSidebar","previous":{"title":"Validator rewards in Casper 2.0","permalink":"/condor/validator-rewards"}}');var i=s(74848),t=s(28453);const a={title:"Zug consensus in Casper 2.0",description:"A discussion of the Zug consensus model",slug:"zug",date:"2024-10-03T18:00",authors:["alexanderlimonov"],tags:["v2","consensus"],hide_table_of_contents:!1},r=void 0,l={},c=[{value:"The Zug consensus mechanism",id:"the-zug-consensus-mechanism",level:2},{value:"Highway",id:"highway",level:2},{value:"Concept",id:"concept",level:3},{value:"Limitations with Highway",id:"limitations-with-highway",level:3},{value:"Zug",id:"zug",level:2},{value:"How Zug works",id:"how-zug-works",level:3},{value:"Impact on validator set size",id:"impact-on-validator-set-size",level:2},{value:"Summary",id:"summary",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"the-zug-consensus-mechanism",children:"The Zug consensus mechanism"}),"\n",(0,i.jsx)(n.p,{children:"In this article we will break down the Zug consensus mechanism in Casper v2.0"}),"\n",(0,i.jsx)(n.h2,{id:"highway",children:"Highway"}),"\n",(0,i.jsx)(n.p,{children:"The Highway consensus protocol, developed by CasperLabs, was the first in-house consensus protocol that was deployed with the launch of 1.0 mainnet."}),"\n",(0,i.jsx)(n.h3,{id:"concept",children:"Concept"}),"\n",(0,i.jsx)(n.p,{children:'Highway\'s distinctive feature is the ability to explicitly vary the "speed" of different validators by dynamically altering a parameter that governs which and how many rounds they participate in within an era.'}),"\n",(0,i.jsx)(n.h3,{id:"limitations-with-highway",children:"Limitations with Highway"}),"\n",(0,i.jsx)(n.p,{children:'Highway is highly complex and opaque. It is difficult to develop a good intuition for how the internal state of the protocol evolves. Additionally, the ability to vary validators "speed" was likely of limited benefit, since, in practice, the maximum "speed" (i.e., block time) was set conservatively.'}),"\n",(0,i.jsx)(n.h2,{id:"zug",children:"Zug"}),"\n",(0,i.jsx)(n.p,{children:"Due to limitations of Highway, a simpler protocol, called Zug, was developed. Its internal state is much simpler, allowing the same number of validators to quickly reach consensus with fewer messages."}),"\n",(0,i.jsx)(n.h3,{id:"how-zug-works",children:"How Zug works"}),"\n",(0,i.jsx)(n.p,{children:"The Zug protocol can be summarized as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["In every round, the round leader proposes a new block, ",(0,i.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Every validator creates and broadcasts an ",(0,i.jsx)(n.em,{children:"echo"})," message, with a signature of ",(0,i.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["When a suitable block ",(0,i.jsx)(n.code,{children:"B"})," has received echoes from 67% of the validators:\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The next round begins. The next leader can propose a child of ",(0,i.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Every validator signs and broadcasts a ",(0,i.jsx)(n.em,{children:"vote"})," message, voting ",(0,i.jsx)(n.code,{children:"yes"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["If this does not happen before a timeout, the validators vote ",(0,i.jsx)(n.code,{children:"no"})," instead.\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If there are ",(0,i.jsx)(n.code,{children:"no"})," votes from 67%, the next round begins, too.\nThe next leader can propose a child from an earlier block and skip this round."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["If there are ",(0,i.jsx)(n.code,{children:"yes"})," votes from 67%, ",(0,i.jsx)(n.code,{children:"B"})," is finalized and gets executed, together with all its ancestors. (Usually, the next round has already started at this point.)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that proposals, votes, and echoes are broadcast, so if one correct node receives a message, all nodes will eventually receive it. An honest validator sends only one echo or vote per round. So, unless 34% of validators double-sign, at most one block per round gets 67% echoes, and no finalized block can ever be skipped, ensuring safety. As long as there are 67% of echoes for a proposal, the next round begins and Zug doesn't get stuck. If there are not, everyone votes ",(0,i.jsx)(n.code,{children:"no"}),", and the next round also begins."]}),"\n",(0,i.jsx)(n.h2,{id:"impact-on-validator-set-size",children:"Impact on validator set size"}),"\n",(0,i.jsx)(n.p,{children:"Because Zug has a smaller communication overhead, it may allow an increase in the size of the validator set."}),"\n",(0,i.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"The adoption of the Zug protocol represents a leap for ward for the Casper network in terms of efficiency and extensibility."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var o=s(96540);const i={},t=o.createContext(i);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);